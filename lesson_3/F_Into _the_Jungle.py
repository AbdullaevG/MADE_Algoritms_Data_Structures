'''
F. Поляна дров
ограничение по времени на тест: 2 секунды
ограничение по памяти на тест: 256 мегабайт
ввод: стандартный ввод
вывод: стандартный вывод
Маленький мальчик Ферма живет в деревне. Наступают холодные времена, поэтому бабушка попросила мальчика сходить в лес,
чтобы собрать дров. В лесу около деревни, в которой живет Ферма, находится волшебная Поляна Дров,
на которой всегда лежат дрова, и никогда не кончаются. Естественно, Ферма должен пойти именно туда.
Единственная проблема заключается в том, что идти до Поляны не очень близко, тем более что скорость передвижения
по лесу намного меньше, чем скорость передвижения по полю, в котором находится деревня.
 Деревня находится в точке с координатами  (0,1).
 Поляна находится в точке с координатами  (1,0).
 Граница между лесом и полем — горизонтальная прямая y=a, где a — некоторое число (0≤a≤1).
 Скорость передвижения по полю составляет Vp, скорость передвижения по лесу — Vf.
 Вдоль границы можно двигаться как по лесу, так и по полю.
Найдите точку, в которой мальчик Ферма должен войти в лес, чтобы дойти до Поляны Дров как можно быстрее.
Входные данные
В первой строке входного файла содержатся два положительных целых числа — Vp и Vf (1≤Vp,Vf≤10^5).
Во второй строке содержится единственное вещественное число — координата по оси Oy границы между лесом и полем a (0≤a≤1)
Выходные данные
В единственной строке выходного файла выведите вещественное число с точностью не менее 4 знаков после запятой
— координата по оси Ox точки, в которой мальчик Ферма должен войти в лес.
Пример
входные данные
5 3
0.4
выходные данные
0.783310604
'''


import math

START_X, START_Y = 0, 1
FINISH_X, FINISH_Y = 1, 0

MIN_VELOCITY = 1
MAX_TIME = (abs(FINISH_X - START_X) + abs(FINISH_Y - START_Y)) / MIN_VELOCITY
MIN_TIME = 0

EPS = 10 ** (-9)
NUM_ITER = int(math.log2((MAX_TIME - MIN_TIME) / EPS))


def arbitr_traj_time(x):
    global border_location, meadow_vel, forest_vel

    time_for_meadow = ((x - START_X) ** 2 + (border_location - START_Y) ** 2) ** 0.5 / meadow_vel
    time_for_forest = ((FINISH_X - x) ** 2 + (FINISH_Y - border_location) ** 2) ** 0.5 / forest_vel

    return time_for_meadow + time_for_forest


def get_min_time(left_edge, right_edge):

    for _ in range(NUM_ITER):
        left_third =  left_edge + (right_edge - left_edge) / 3
        right_third = left_edge + 2 * (right_edge - left_edge) / 3

        if arbitr_traj_time(left_third) < arbitr_traj_time(right_third):
            right_edge = right_third
        else:
            left_edge = left_third

    return round(right_edge, 5)


meadow_vel, forest_vel = map(int, input().split())
border_location = float(input())
print(get_min_time(0, MAX_TIME))